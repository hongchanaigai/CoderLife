day003课程回顾：

1、C语言概述：语言发展历史（机器语言、汇编语言和编译器、高级语言）
2、（重要）第一个C语言程序（头文件、主函数、注释、语句通常以“;”结束）
3、gcc编译器：（重要）使用gcc编译C代码“gcc hello.c -o hello”（Linux平台）
	C语言编译过程：C程序编译步骤（预处理“头文件展开”、编译“生成汇编代码”、汇编“生成目标代码”、链接“链接动态库”）
	（重要）分步编译：  预处理“gcc -E hello.c -o hello.i”
			编译   “gcc -S hello.i -o hello.s”
			汇编   “gcc -c hello.s -o hello.o”
			链接   “gcc hello.o -o hello”
4、system函数：（重要）system函数的使用（“system("ls");”//Linux平台，需要头文件“#include<stdlib.h>”）
	system返回值不同系统结果不一样
	（重要）QT图像界面调用system
	MFC图像界面调用system
5、汇编语言：VS中C语言嵌套汇编代码；VS反汇编
6、集成开发环境IDE：QT Creator、Microsoft visual studio（VS的C4996错误）
		两种方式解决：#define _CRT_SECURE_NO_WARNINGS //这个宏定义最好放在.c文件第一行
			       #pragma warning(disable:4996) //或者使用这个




day004课堂笔记：

数据类型的作用：编译器预算对象（变量）分配的内存空间大小
		告诉编译器定义这么一个类型的变量需要分配多大的空间


常量：程序运行过程中，值不能被改变；一般出现在表达式或赋值语句中（100、3.14、"abc"、'a'）
变量：程序运行过程中，值可以被改变；变量在使用前必须先定义，定义变量必须有相应的数据类型
标识符命名规范：1、不能是关键字；2、只能有字母、数字、下划线组成；
		3、第一个字符必须是字母或下划线；4、区分大小写


右边是低位，左边是高位
123；

2进制转10进制（8421）
1110 = 14（8+4+2）
1010 = 10（8+2）
0001 = 1（1）
1001 = 9（8+1）

8进制转10进制，16进制转10进制都类似（逢X进1）


数据在计算机中主要以补码形式存储的
bit（比特）	byte（字节）计算机存储的最小单位	word（双字节）	DWORD（两个word）
1 byte = 8 bit
1b(bit)	1B(Byte)	1k/1K(1024B)	1M(兆1024k)	1G（1024M）	1T（1024G）


X进制转换成2进制（X进制就除X，直到商=0，余数倒序读即可）

2进制和8进制转换：8进制一位对应2进制三位
从右往左分
010 111 101 010 101 010 010 101
2      7     5    2     5     2     2     5

1      2      3      4      5      6      7
001  010  011  100  101  110  111

2进制16进制转换：16进制的一位对应2进制的四位
0101  1110  1010  1010  1001  0101
5        E         A       A        9        5

9        A        8        F         7
1001  1010  1000  1111  0111

8进制和16进制转换（借助2进制）


原码，反码，补码
1、存储1字节（8位）大小的数字（char）

	原码（用户角度）：原始的2进制
		用户的数字分为正负数，符号位的存储；
		最高位为符号位：0代表正数，1代表负数；
		1000  00001  左边是高位，右边是低位；
		1，+1：0000 0001		-1：1000 0001
		0，+0：0000 0000		-0：1000 0000
	原码存储导致2个问题：0有两种存储方式；
		正数和负数相加，结果不正确（计算机只会加不会减）
		以原码算：1-1 = 1+（-1）结果为1000 0010 = -2


	反码（为了算原码）：正数的原码和反码一样；求原码；
		负数在原码基础上，符号位不变，其他位取反（0位1，1为0）
		1，+1：0000 0001		-1：1111 1110
		0，+0：0000 0000		-0：1111 1111	
	反码存储导致1个问题：0有两种存储方式；
		以反码算：1-1 = 1+（-1）结果为1111 1111 = -0


2、计算机存储数字以补码方式存储（为了解决负数的存储）

	补码：正数的原码、反码、补码都一样；负数补码 = 反码 + 1
		1，+1：0000 0001		-1：1111 1111
		0，+0：0000 0000		-0：1 0000 0000（只存8位，最高位丢弃0000 0000）
		以补码算：1-1 = 1+（-1）结果为1 0000 0000 = 0（最高位丢弃）

3、10进制数，站在用户角度，原码；
   2进制、8进制、16进制，站在计算机角度，补码
   
//1个字节
1000 0001
81

原码求补码：
1、最高位符号位，其他位就是二进制（原码）
2、在1、的基础上，符号位不变，其他位取反
3、在2、的基础上加1

补码求原码：
1、补码
2、求补码的反码，符号位不变，其他位取反
3、原码在2、的基础上加1

//2进制、8进制、16进制，站在计算机角度，补码
//0x81转换为2进制为1000 0001，最高位为1，说明是负数
char a = 0x81;
补码：1000 0001
反码：1111 1110
原码：1111 1111 = -127

//10进制数，站在用户角度，原码
printf("%d\n", a);	//-127


//2进制、8进制、16进制，站在计算机角度，补码
//0xe5的2进制为1110 0101，最高位为1，说明是负数，它是负数的补码
char b = 0xe5;
补码：1110 0101
反码：1001 1010
原码：1001 1011 = -27

printf("%d\n", b);	//-27


0x6f的2进制为0110 1111，最高位为0，是正数
char c = 0x6f;
printf("%d\n", b);	//111



//10进制数，站在用户角度，原码
int a = -123;
原码: 1000 0000 0000 0000 0000 0000 0111 1011
反码: 1111 1111 1111 1111 1111 1111 1000 0100
补码: 1111 1111 1111 1111 1111 1111 1000 0101
		f	 f	  f	   f	f	 f	  8	   5

%x，默认以4个字节(32为)大小打印
//2进制、8进制、16进制，站在计算机角度，补码
printf("%x\n", a);



有符号和无符号的区别:
1)有符号,最高位为符号位,0代表正数，1代表负数；
2)无符号,最高位不是符号位,是数的一部分,无符号不可能是负数

1000 0000 0000 0000 0000 0000 0111 1011
8	 0	  0	   0	0	 0	  7	   b

//%d,默认以有符号的方式打印
原码:1000 0000 0000 0000 0000 0000 0111 1011
反码:1111 1111 1111 1111 1111 1111 1000 0100
补码:1111 1111 1111 1111 1111 1111 1000 0101
	 -7	   f	f	 f	  f	   f	8	 5 = -2147483525

printf("%x\n", 0x8000007b);

//%u,以无符号的方式打印

1000 0000 0000 0000 0000 0000 0111 1011
8	 0	  0	   0	0	 0	  7	   b = 2147483771

printf("%u\n", 0x8000007b);

signed int a;


数据类型范围:

char 1个字节(8位)

有符号的范围:
1)正数:0000 0000 ~ 0111 1111(0 ~ 127)
2)负数:1000 0000 ~ 1111 1111(-0 ~ -127)(-0 当做 -128 使用)
	-128:
	原码:1 1000 0000
	反码:1 0111 1111
	补码:1 1000 0000
	
无符号的范围:0000 0000 ~ 1111 1111(0 ~ 255)

char:
有符号:-128 ~ 127
无符号:0 ~ 255

赋值或者运算,记得不要越界
char a = 127 + 2;
129转换成2进制1000 0001,这是负数补码
补码:1000 0001
反码:1111 1110
原码:1111 1111(最高位是符号位)-127

printf("%d\n", a);


unsigned char b = 255 + 2;
257转换为2进制0001 0000 0001(只取后8位)

printf("%u\n", b);


man ascii查看ASCII码表












