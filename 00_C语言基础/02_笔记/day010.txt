day009 课程回顾

一. 看画的几个图

	1. 指针数组,是数组,每个元素都是指针

	2. 字符指针,是指针,指向字符类型的数组

	3. 字符串拷贝问题,段错误,字符串常量是存放在data(文字常量区),不允许修改
	
二. 作业讲解

	1. 实现my_atoi()函数
		关键步骤: num = num * 10 + (*tmp - '0'); //上一次的数 * 10 + 这次的字符数
		
	2. 注意使用strtok()时,原始字符串会被破坏,所以拷贝一份使用,保留原件
	
	
	
	
	
day010 课堂记录



//1. 不能改p1指向的内存,char const *p1
//2. p1指向文字常量区的指针变量
char *p1 = "abc";
char tmp[100];
strcpy(tmp, p1); //这样以后,就可以修改tmp中的元素

//1. 可以改变数组的元素
//2. 把"abc"拷贝到数组p2中
char p2[] = "abc";

char p3[100];
//p3 = "abc"; //error,数组名是常量
strcpy(p3, "abc");



//类比
int a, b, c;
//指针数组,它是数组,每个元素都是指针
//每个元素都是int *,都是指向int
int * p[] = {&a, &b, &c};

char a1, b1, c1;
char * p1[] = {&a1, &b1, &c1};


char *str1 = "abc";
char *str2 = "hello";
char *str3 = "huang";

//p2,它是数组,它保存了3个字符串的首元素地址
char * p2[] = {"abc", "hello", "huang"};

char *p2[3];
p2[0] = "abc";
p2[1] = "hello";
p2[2] = "huang";


char * p2[] = {"abc", "hello", "huang"};

//p2是char **,类型,指向char *
//p2是指针
char * *p2 = {"abc", "hello", "huang"}; //error


char * tmp;
char * * p = &tmp; //ok


//str首元素是什么类型? char *
//&str[0],代表首元素地址,str等价于&str[0]
char * str[] = {"abc", "hello", "huang"};
char * * p = str; //char * *指向char *
char * * p = &str[0];


func(str);
//如果char * str[]作为函数参数,可以改成char * * str
void func(char * * p);


//下面3种,编译器都当做char * * p处理
void func(char * * p);
void func(char * p[]);
void func(char * p[100]);

void func(char a[]);
void func(char a[100]);
void func(char * a);



作用域和生命周期:

	作用域:作用的范围
	
		1. 普通局部变量
			//1. 在{}内部定义的变量就是局部变量
			//2. 只有执行到定义变量的这个语句,系统才会给变量分配空间
			//3. 当离开{},这个非static局部自动释放
			//4. 局部变量的作用域在当前的{},离开此{},无法使用此变量
			//5. {}的普通局部变量,加不加auto关键字等价,不同局部变量也叫自动变量
			//6. 不同的{}中,变量名字可以一样,可以把{}类比房子,不同房子可以有同名的人
			//7. 普通局部变量不初始化,它的值为随机数
		
		2. static局部变量
			//1. 在{}内部定义的变量就是局部变量 
			//2. static局部变量,实在编译阶段就已经分配空间,函数没有调用前,它就就已经存在
			//3. 当离开{},static局部变量不会释放,只有程序结束,static变量才会释放
			//4. 局部变量的作用域在当前的{},离开此{},无法使用此变量
			//5. 不同的{}中,变量名字可以一样,可以把{}类比房子,不同房子可以有同名的人
			//6. 如果static局部变量不初始化,它的值默认为0
			//7. static局部变量初始化语句,只会执行一次,但是可以赋值多次
			//8. static变量只能用常量初始化(注意)
			
		普通局部变量和static局部变量的区别:
			1. 内存分配和释放的区别
				1) 普通局部变量只有执行到定义变量的语句才分配空间
				2) static局部变量在编译阶段(函数还没有执行),变量的空间已经分配
				3) 普通局部变量离开作用域{},自动释放
				4) static局部变量只有在整个程序结束才自动释放
				
			2. 初始化
				1) 普通局部变量不初始化,值为随机数
				2) static局部变量不初始化,值为0
				3) static局部变量初始化语句只有第一次执行时有效
				4) static局部变量只能用常量初始化
		
		3. 普通全局变量(外部链接)
			//1. 在{}外面(函数外面)定义的变量为全局变量
			//2. 只要定义了全局变量,任何地方都能使用此变量
			//3. 如果使用变量时,在前面找不到此全局变量的定义,需要声明后才能使用
			//4. 全局变量不初始化,默认赋值为0
			//5. 声明只是针对全局变量,不是针对局部变量
			//6. 全局变量只能定义一次,可以声明多次
			//7. 全局变量在编译阶段已经分配空间(函数没有执行前),只要在整个程序结束,才自动释放
			//8. 不同文件,普通全局变量只能定义一次,可以声明多次

		普通全局变量的定义和声明:
			//1. 定义一个全局变量,建议初始化
			int a = 10; 

			//2. 如果声明一个全局变量,建议加extern关键字
			extern int a;
			
			//3. 防止头文件重复包含
			//#pragma once
			#ifndef A.H
			#define A.H
			
			//定义一个全局变量
			int a = 0;
			
			#endif //A.H
			
			防止头文件重复包含:同一个文件包含n次头文件,这个文件只有一次有效

		4. static全局变量(内部链接)
			1) static全局变量和普通全局变量的区别就是作用域不一样(文件作用域)
			2) extern关键字只适用于普通全局变量
			3) 普通全局变量,所有文件都能使用,前提需要声明
			4) static全局变量,只能本文件使用,别的文件不能使用
			5) 不同文件只能出现一个普通全局变量的定义
			6) 一个文件只能有一个static全局变量的定义,不同文件之间的static全局变量,就算名字相同,也是没有关系的2个变量
		
		5. 普通函数和static函数的区别(文件作用域)
			1) 所有文件只能有一次普通函数的定义
			2) 一个文件可以有一个static函数的定义
			3) 普通函数所有文件都能调用,前提是使用前声明
			4) static函数只能在定义所在的文件中使用
			


在程序没有执行前,有几个内存分区已经确定,虽然分区确定,但是没有加载内存,程序只有运行时才加载内存
	text(代码区):只读,函数
	data:初始化的数据,全局变量,static变量,文字常量区(只读)
	bss:没有初始化的数据,全局变量,static变量

当运行程序,加载内存,首先根据前面确定的内存分区(text,data,bss)先加载,然后额外加载2个区(栈区(stack),堆区(heap))
	text(代码区):只读,函数
	data:初始化的数据,全局变量,static变量,文字常量区(只读)
	bss:没有初始化的数据,全局变量,static变量
	stack(栈区):普通局部变量,自动管理内存,先进后出的特点
	heap(堆区):手动申请空间,手动释放,整个程序结束,系统也会自动回收,如果没有手动释放,程序也没有结束,这个堆区空间不会释放

查看栈区等大小命令(Linux): ulimit -a

内存泄露: 动态分配了空间,不释放
内存污染: 非法使用内存




